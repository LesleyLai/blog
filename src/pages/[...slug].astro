---
import {
  getCollection,
  type CollectionEntry,
  type Render,
  type InferEntrySchema,
} from "astro:content";

import Layout from "@layouts/BaseLayout.astro";
import { isLanguage, type Language } from "@i18n/i18n";
import { translations } from "@i18n/translations";
import type { TranslationKey } from "@i18n/translations";
import "@styles/container.css";

export const langFromSlug = (slug: string): Language => {
  let lang = slug.split("/")[0];
  if (!isLanguage(lang)) {
    throw new Error(`Unknown language contained in url ${slug}`);
  }

  return lang;
};

interface BlogPostEntry {
  body: string;
  slug: string;
  data: InferEntrySchema<"blog">;
  untranslated?: boolean;
  render(): Render[".md"];
}

type MultiLangEntries = {
  en?: BlogPostEntry;
  zh?: BlogPostEntry;
};

export const groupEntriesById = (blogEntries: CollectionEntry<"blog">[]) => {
  const byId = new Map<string, MultiLangEntries>();
  for (const entry of blogEntries) {
    const lang = langFromSlug(entry.slug);
    const id = entry.slug.replace(`${lang}\/`, "");
    if (!byId.has(id)) {
      byId.set(id, {});
    }
    byId.get(id)![lang] = entry;
  }

  return byId;
};

type GetStaticPathsResult = {
  params: {
    slug: string;
  };
  props: {
    entry: BlogPostEntry;
  };
};

export async function getStaticPaths() {
  const blogEntries = await getCollection("blog");

  const blogEntriesById = groupEntriesById(blogEntries);

  blogEntriesById.forEach((entries: MultiLangEntries, id: string) => {
    if (!entries.zh) {
      const en = entries.en!;
      entries.zh = {
        body: en.body,
        data: en.data,
        untranslated: true,
        render: en.render,
        slug: `zh/${id}`,
      };
    }
  });

  const result: GetStaticPathsResult[] = [];
  blogEntriesById.forEach((entries: MultiLangEntries, id: string) => {
    for (let [lang, entry] of Object.entries(entries)) {
      result.push({
        params: { slug: `/${lang}/${id}` },
        props: { entry },
      });
    }
  });

  return result;
}

const { entry } = Astro.props;
const { Content } = await entry.render();

const lang = langFromSlug(entry.slug);

const options: Intl.DateTimeFormatOptions = {
  year: "numeric",
  month: "long",
  day: "numeric",
};
const formatDate = (date: Date) => date.toLocaleDateString(lang, options);

const modified = entry.data.created.getTime() < entry.data.modified.getTime();

const translate_tags = (tag: string): unknown => {
  if (tag in translations.en) {
    return translations[lang][tag as TranslationKey];
  }
  throw Error(`Failed to translate tag: ${tag}`);
};
---

<Layout title={entry.data.title}>
  <div class="container container-shadow">
    <main class="post-main">
      <h1>
        {entry.data.title}
        {entry.untranslated && <span class="untranslated">{translations[lang].untranslated}</span>}
      </h1>
      <div class="info">
        <span class="date">
          {modified ? `last modify: ${formatDate(entry.data.modified)} | ` : undefined}
          create: {formatDate(entry.data.created)}
        </span>
        <span class="tags">
          <ul class="tagList">{entry.data.tags.map((tag) => <li>{translate_tags(tag)}</li>)}</ul>
        </span>
      </div>
      <Content />
    </main>
  </div>
</Layout>

<style>
  .container {
    background-color: var(--sidenote-bg-color);
  }

  @media only screen and (min-width: 1088px) {
    main {
      max-width: var(--blog-content-width);
    }
  }

  h1 {
    font-size: max(36px, 2em);
    line-height: 48px;
    font-weight: 400;
    margin: 100px 0;
  }

  .untranslated {
    font-size: 0.8em;
  }

  .info {
    border-bottom: 1px solid var(--divider-color);
    padding-bottom: 4px;
    margin-bottom: 1rem;
    font-size: 13px;

    display: flex;
    justify-content: space-between;
  }

  .tagList {
    /* TODO: shouldn't need to reset list */
    list-style: none;
    margin: 0;

    display: flex;
  }

  .tagList li {
    margin: 0.2em 0.5em 0.2em 0px;

    padding: 0.4em 0.5em;
    font-weight: 700;
    font-size: 10px;
    border-radius: 0.285714rem;
    color: #fff;
    background-color: var(--tag-color);
  }

  .date {
    color: var(--secondary-color);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  /* sidenotes */
  main :global(aside) {
    color: var(--aside-text-color);
    padding: 5px 10px;
    font-size: 13px;

    margin-bottom: 20px;
    background: var(--aside-sm-bg-color);
    border: solid 1px var(--aside-sm-border-color);
    border-bottom: solid 1px var(--aside-sm-border-bottom-color);
    border-radius: 10px;
  }

  @media only screen and (max-width: 1087px) {
    main :global(aside) {
      margin-top: 0 !important;
    }
  }

  @media only screen and (min-width: 1088px) {
    main :global(aside) {
      position: absolute;
      width: calc(var(--container-width) - var(--blog-content-width) - 11px);
      background: none;
      padding: 0 0 0 16px;
      border-radius: 0;
      border: none;
      border-left: 8px solid var(--aside-lg-border-color);
      right: calc((100% - var(--container-width)) / 2 + 14px);
    }
  }
</style>
